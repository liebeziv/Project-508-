x86汇编与恶意代码分析知识点
1. x86语法基础
参数顺序 (Parameter Order)

AT&T语法: movl $5, %eax (源操作数在前，目标操作数在后)
Intel语法: mov eax, 5 (目标操作数在前，源操作数在后)

参数大小 (Parameter Size)

AT&T: 使用后缀表示大小

addl (long, 32位)
movslq (符号扩展)
paddq (quad word)


Intel: 从寄存器名称推导大小

add esp, 24h
movsx rax, ecx
paddq xmm2, xmm1



立即数和有效地址 (Immediate Values & Effective Addresses)

AT&T: 立即数前缀$，寄存器前缀%
Intel: 汇编器自动检测符号类型
有效地址示例:

AT&T: movl offset(%ebx, %ecx, 4), %eax
Intel: mov eax, [ebx + ecx*4 + offset]



2. x86架构组成
CPU架构图
CPU
├── Registers (寄存器)
├── ALU (算术逻辑单元)
└── Control Unit (控制单元)
    ↕
Main Memory (主存储器)
├── Stack (栈)
├── Heap (堆)
├── PE Header
├── Code (代码段)
└── Data (.data, .rdata, .rsrc)
    ↕
Input/Output Devices (输入输出设备)
3. 寄存器系统
通用寄存器 (General Registers)
32位: EAX, EBX, ECX, EDX
16位: AX,  BX,  CX,  DX
8位:  AH/AL, BH/BL, CH/CL, DH/DL
指针和索引寄存器 (Pointer and Index Registers)

ESI (Source Index)
EDI (Destination Index)
ESP (Stack Pointer)
EBP (Base Pointer)
EIP (Instruction Pointer)

标志寄存器 (Flag Register)

ZF (Zero Flag): 结果为0时设置
CF (Carry Flag): 进位/借位时设置
SF (Sign Flag): 结果为负时设置
TF (Trap Flag): 单步调试

寄存器特殊用途

EAX: 函数返回值，乘除法操作
EDX: 与EAX配合进行64位乘除法
ECX: 循环计数器
ESP: 栈顶指针

4. 数据传输指令
MOV指令
assemblymov dst, src  ; 将src的值复制到dst

; 常量到寄存器
mov eax, 10
mov bx, 7
mov eax, 64h

; 寄存器间传输
mov eax, ebx

; 内存到寄存器
mov eax, [0x403000]
mov eax, [ebx]
mov ebx, [ebp-4]

; 寄存器到内存
mov [0x403000], eax
mov [ebx], eax
LEA指令 (Load Effective Address)
assemblylea dst, src  ; 加载源操作数的地址到目标

mov ebx, [0x403000]  ; 加载地址0x403000处的值到ebx
lea ebx, [0x403000]  ; 加载地址0x403000到ebx
数据大小指示符

word ptr: 16位值
dword ptr: 32位值

5. 算术运算指令
基本算术操作
assemblyadd eax, 42      ; eax = eax + 42
add eax, ebx     ; eax = eax + ebx
add [ebx], 42    ; 将42加到ebx指向的内存地址的值

sub eax, 64h     ; eax = eax - 64h
inc eax          ; eax = eax + 1
dec ebx          ; ebx = ebx - 1
汇编示例转换
c// C代码
int a = 22, b = 5, c, d;
c = a + b;
d = a - b;
assembly; 对应汇编
mov dword ptr [a], 16h     ; a = 22 (16h)
mov dword ptr [b], 5       ; b = 5
mov eax, [a]               ; eax = a
add eax, [b]               ; eax = eax + b
mov [c], eax               ; c = eax
mov ecx, [a]               ; ecx = a
sub ecx, [b]               ; ecx = ecx - b
mov [d], ecx               ; d = ecx
6. 乘除法操作
乘法指令 (MUL)
乘法使用预定义寄存器：

8位操作数: mul bl → AL × BL，结果存在AX
16位操作数: mul bx → AX × BX，结果存在DX:AX
32位操作数: mul ebx → EAX × EBX，结果存在EDX:EAX

除法指令 (DIV)
assembly; 被除数放在EDX:EAX中
mov eax, 1902h    ; 被除数低32位
mov ebx, 320h     ; 除数
div ebx           ; EDX:EAX ÷ EBX
; 结果: EAX = 商(8), EDX = 余数(2)
乘除法示例
assembly; 乘法: 100h × 15h = 1500h (256 × 21 = 5376)
mov eax, 100h
mov ebx, 15h
mul ebx          ; EDX:EAX = 1500h

; 除法: 1902h ÷ 320h = 8余2 (6402 ÷ 800 = 8余2)
mov eax, 1902h
mov ebx, 320h
div ebx          ; EAX = 8, EDX = 2
7. 位运算操作
基本位运算
assemblynot dst          ; 按位取反
and dst, src     ; 按位与
or dst, src      ; 按位或
xor dst, src     ; 按位异或

; 示例: 清零寄存器的常用技巧
xor eax, eax     ; eax = 0 (任何数异或自己等于0)
移位和循环操作
assemblyshl dst, count   ; 左移
shr dst, count   ; 右移
rol dst, count   ; 循环左移
ror dst, count   ; 循环右移

; 示例
mov al, 16h      ; al = 00010110 (22)
shr al, 1        ; al = 00001011 (11)
ror al, 2        ; al = 10000101 (133)
8. 分支控制
条件跳转前的比较指令
assemblycmp dst, src     ; 比较dst和src，设置标志位
test dst, src    ; dst AND src，常用于检查寄存器是否为0
CMP指令标志位设置
比较结果ZFCFdst = src10dst < src01dst > src00
常用条件跳转指令
指令描述条件jz/je相等跳转ZF = 1jnz/jne不等跳转ZF = 0jg大于跳转(有符号)ZF=0 且 SF=OFjge大于等于跳转(有符号)SF = OFjl小于跳转(有符号)SF ≠ OFjle小于等于跳转(有符号)ZF=1 或 SF≠OFja大于跳转(无符号)CF=0 且 ZF=0jae大于等于跳转(无符号)CF = 0jb小于跳转(无符号)CF = 1jbe小于等于跳转(无符号)CF=1 或 ZF=1
9. 控制结构模式
IF语句模式
c// C代码
if (x == 0) {
    x = 5;
}
x = 2;
assembly; 对应汇编
cmp dword ptr [x], 0    ; 比较x与0
jne end_if              ; 如果不相等跳转到end_if
mov dword ptr [x], 5    ; x = 5
end_if:
mov dword ptr [x], 2    ; x = 2
IF-ELSE语句模式
c// C代码
if (x == 0) {
    x = 5;
} else {
    x = 1;
}
assembly; 对应汇编
cmp dword ptr [x], 0
jne else                ; 不等于0跳转到else
mov dword ptr [x], 5    ; x = 5
jmp end                 ; 跳转到结束
else:
mov dword ptr [x], 1    ; x = 1
end:
循环结构模式
c// C代码
int i = 0;
while (i < 5) {
    i++;
}
assembly; 对应汇编
mov [i], 0              ; i = 0
while:
cmp [i], 5              ; 比较i与5
jge end                 ; i >= 5时跳出循环
mov eax, [i]            ; 加载i的值
add eax, 1              ; i++
mov [i], eax            ; 存储新值
jmp while               ; 回到循环开始
end:
10. 代码模式识别 (拓展内容)
识别控制结构的特征

IF语句: 向前跳转 + 可能的无条件跳转
循环: 向前跳转 + 向后无条件跳转
函数调用: call指令 + ret指令

恶意代码分析中的重要模式 (拓展内容)

加密/解密循环: 重复的异或操作
字符串解混淆: 循环中的算术运算
反调试检测: 特定标志位检查


可能考题及答案
选择题 (MCQs)
Q1: 在Intel语法中，指令 mov eax, ebx 的含义是什么？
A) 将eax的值复制到ebx
B) 将ebx的值复制到eax
C) 将eax和ebx的值交换
D) 比较eax和ebx的值
答案: B
Q2: 32位乘法 mul ebx 的结果存储在哪里？
A) 仅EAX中
B) 仅EBX中
C) EDX:EAX中
D) EBX:EAX中
答案: C
Q3: 指令 test eax, eax 主要用于检查什么？
A) eax是否为负数
B) eax是否为0
C) eax是否为偶数
D) eax的最高位
答案: B
Q4: 下列哪个寄存器通常用于存储函数返回值？
A) EBX
B) ECX
C) EDX
D) EAX
答案: D
简答题 (Short Questions)
Q1: 解释lea和mov指令在处理内存地址时的区别。(5分)
答案:

mov ebx, [0x403000]: 加载地址0x403000处存储的值到ebx寄存器
lea ebx, [0x403000]: 加载地址0x403000本身到ebx寄存器
lea指令加载的是地址，mov指令加载的是地址处的内容

Q2: 列出x86架构中的三种寄存器类型及其主要用途。(6分)
答案:

通用寄存器: EAX, EBX, ECX, EDX - 主要用于程序执行中的数据存储
指针和索引寄存器: ESP, EBP, ESI, EDI, EIP - 主要用于存储内存地址
标志寄存器: 包含ZF, CF, SF, TF等 - 用于程序控制和决策

Q3: 在汇编代码中如何识别循环结构？(4分)
答案:
循环结构的特征：

向前的条件跳转（用于退出循环）
向后的无条件跳转（回到循环开始）
循环变量的递增/递减操作
循环条件的比较操作

长答题 (Long Questions)
Q1: 将以下C代码转换为x86汇编代码，并解释每条指令的作用。(15分)
cint x = 10, y = 3, result;
if (x > y) {
    result = x * y;
} else {
    result = x + y;
}
答案:
assemblymov dword ptr [x], 10          ; 初始化x = 10
mov dword ptr [y], 3           ; 初始化y = 3
mov eax, [x]                   ; 加载x的值到eax
cmp eax, [y]                   ; 比较x和y的值
jle else_branch                ; 如果x <= y，跳转到else分支
mov eax, [x]                   ; 加载x到eax
mov ebx, [y]                   ; 加载y到ebx  
mul ebx                        ; eax = x * y
mov [result], eax              ; 存储乘法结果
jmp end_if                     ; 跳转到结束
else_branch:
mov eax, [x]                   ; 加载x到eax
add eax, [y]                   ; eax = x + y
mov [result], eax              ; 存储加法结果
end_if:
指令说明:

mov: 数据传输指令
cmp: 比较指令，设置标志位
jle: 条件跳转，小于等于时跳转
mul: 乘法指令，使用预定义寄存器
add: 加法指令
jmp: 无条件跳转

Q2: 分析以下汇编代码的功能，并将其转换为等效的C代码。(12分)
assemblymov dword ptr [ebp-4], 0       ; 初始化变量
mov dword ptr [ebp-8], 1       ; 初始化变量
loop_start:
cmp dword ptr [ebp-4], 10      ; 比较条件
jge loop_end                   ; 退出条件
mov eax, [ebp-8]               ; 加载值
add eax, [ebp-4]               ; 执行加法
mov [ebp-8], eax               ; 存储结果
inc dword ptr [ebp-4]          ; 递增计数器
jmp loop_start                 ; 回到循环开始
loop_end:
答案:
这段汇编代码实现了一个累加循环：
cint i = 0;        // [ebp-4]
int sum = 1;      // [ebp-8]
while (i < 10) {
    sum = sum + i;
    i++;
}
分析:

[ebp-4]是循环计数器i，初始值为0
[ebp-8]是累加器sum，初始值为1
循环条件是i < 10
每次迭代将i加到sum上，然后i递增
最终sum的值为1+0+1+2+...+9 = 46
