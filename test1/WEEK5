x86汇编与恶意软件分析知识点
1. 代码模式识别 (Code Patterns)
循环结构 (Loops)
assemblymov dword ptr [ebp-8], 1    ; 初始化变量
mov dword ptr [ebp-4], 0    ; 循环计数器
label1:
cmp dword ptr [ebp-4], 4    ; 比较条件
jge short label2            ; 条件跳转 (前向跳转)
mov eax, [ebp-8]
add eax, [ebp-4]
mov [ebp-8], eax
mov ecx, [ebp-4]
add ecx, 1
mov [ebp-4], ecx
jmp short label1            ; 无条件后向跳转
label2:
特征: 前向跳转 + 无条件后向跳转
分支结构 (Branching)
assemblycmp eax, 0
jz label1                   ; 条件跳转
mov ebx, 2
jmp label2                  ; 无条件跳转
label1: 
mov ebx, 1
label2:
特征: 前向跳转 + 无条件跳转
2. 栈操作 (Stack Operations)
栈基础

ESP (Stack Pointer): 始终指向栈顶
EBP (Base Pointer): 指示函数的起始位置 (基址)
栈从高地址向低地址增长
push操作: ESP减4; pop操作: ESP加4

栈操作指令
assemblypush src    ; 将源操作数(4字节)压入栈顶
pop dest    ; 从栈顶弹出(4字节)到目的操作数
栈操作示例
assemblypush 3      ; ESP指向新位置，存储3
push 4      ; ESP再次减4，存储4
pop ebx     ; ebx = 4, ESP加4
pop edx     ; edx = 3, ESP加4
3. 函数调用机制 (Function Calling)
函数调用指令
assemblycall <memory_address>   ; 调用函数
ret                     ; 返回函数

call指令: 跳转到指定地址，将返回地址压入栈
ret指令: 从栈中弹出返回地址并跳转

函数结构组件

参数 (Parameters)
函数体代码 (Body - Code)
变量 (Variables)
输入输出 (Input - Output)
参数、局部变量、函数流控制 → 存储在栈上
动态分配内存 → 存储在堆上

函数调用示例
cint test(int a, int b) {
    int x, y;
    x = a; y = b;
    return 0;
}
int main() {
    test(2, 3);
    return 0;
}
main()函数汇编:
assemblypush 3          ; 参数b
push 2          ; 参数a  
call test       ; 调用test函数
add esp, 8      ; 清理栈(2个参数×4字节)
xor eax, eax    ; return 0
函数序言和尾声 (Function Prologue & Epilogue)
函数序言 (Prologue):
assemblypush ebp        ; 保存旧的基指针
mov ebp, esp    ; 设置新的基指针
sub esp, 8      ; 为局部变量分配空间
函数尾声 (Epilogue):
assemblymov esp, ebp    ; 恢复栈指针
pop ebp         ; 恢复基指针
ret             ; 返回
test()函数完整汇编
assemblypush ebp                ; 函数序言
mov ebp, esp
sub esp, 8
mov eax, [ebp+8]        ; 获取参数a
mov [ebp-4], eax        ; x = a
mov ecx, [ebp+0Ch]      ; 获取参数b
mov [ebp-8], ecx        ; y = b
xor eax, eax            ; return 0
mov esp, ebp            ; 函数尾声
pop ebp
ret
4. 数组 (Arrays)
数组基础

数组是相同数据类型的列表
数组元素在内存中连续存储
数组名是指向第一个元素的指针常量

数组访问公式
[base_address + index * size_of_element]
示例
cint nums[3] = {1, 2, 3};

nums[0]: [4000 + 0 * 4 = 4000]
nums[1]: [4000 + 1 * 4 = 4004]
nums[2]: [4000 + 2 * 4 = 4008]

数组汇编识别
assemblypush ebp
mov ebp, esp
sub esp, 14h            ; 分配大量内存空间(数组特征)
mov dword ptr [ebp-14h], 1
mov dword ptr [ebp-10h], 2
mov dword ptr [ebp-0Ch], 3
mov dword ptr [ebp-4], 0    ; 循环变量
数组访问模式:
assemblymov eax, [ebp-4]            ; 获取索引
mov ecx, [ebp+eax*4-14h]    ; 数组访问: base + index*4
5. 字符串 (Strings)
字符串基础

字符串是字符数组
每个ASCII字符占1字节
字符串末尾自动添加null字符(\0)

示例
cchar *str = "Let";
内存布局:

地址0x4000: 'L'
地址0x4001: 'e'
地址0x4002: 't'
地址0x4003: '\0'

6. 内存间移动指令 (Memory-to-Memory Move)
基本指令
assemblymovsb   ; 移动字节 (1字节)
movsw   ; 移动字 (2字节)  
movsd   ; 移动双字 (4字节)

从ESI指向的地址移动数据到EDI指向的地址
移动后ESI和EDI自动更新(增加1、2或4字节)

示例
assemblylea esi, [src]      ; 源地址
lea edi, [dst]      ; 目标地址  
movsb              ; 复制1字节
rep指令
assemblyrep movsb          ; 重复movsb指令ECX次

rep指令依赖ECX寄存器
每次执行后ECX递减
rep + movsx 等价于C语言的memcpy()函数

7. 字符串处理指令
SCASx指令 (扫描)

在字节序列中搜索数据
待搜索数据放在EAX寄存器
内存地址(缓冲区)放在EDI寄存器
通常与repne指令配合使用

assemblyrepne scasb         ; 扫描直到找到或ECX为0
STOSx指令 (存储)

将寄存器值存储到内存位置
从EAX寄存器移动数据到EDI指向的地址

LODSx指令 (加载)

从ESI指向的地址加载数据到EAX寄存器

CMPSx指令 (比较)

比较ESI和EDI指向的内存数据

8. 结构体 (Structures)
结构体基础

将不同类型数据组合在一起
每个元素称为成员 (member)
使用常量偏移访问成员
与数组不同，结构体成员可以是不同数据类型

示例
cstruct simpleStruct {
    int a;          // 偏移0, 4字节
    short int b;    // 偏移4, 2字节  
    char c;         // 偏移6, 1字节
};
结构体操作汇编
assemblymov eax, [ebp+8]            ; 获取结构体指针
mov dword ptr [eax], 6      ; a = 6 (偏移0)
mov ecx, 7
mov [eax+4], ecx           ; b = 7 (偏移4)
mov byte ptr [eax+6], 41h  ; c = 'A' (偏移6)
9. 数据模式总结 (Data Patterns)
变量识别

局部变量: 通过ESP或EBP的偏移访问
assemblymov ecx, [ebp-4]

全局/静态变量: 通过硬编码地址访问
assemblymov eax, [0x77651010]

查看.bss和.data段



栈上数组识别

分配大量内存空间

assemblypush ebp
mov ebp, esp
sub esp, 256        ; 分配256字节(数组特征)
10. x64架构扩展
寄存器扩展

处理64位(8字节)数据
地址和指针都是64位
32位寄存器仍然存在: eax, ebx, ecx, edx, esi, edi, ebp, esp
对应的64位寄存器: rax, rbx, rcx, rdx, rsi, rdi, rbp, rsp
寄存器层次: RAX(64位) > EAX(32位) > AX(16位) > AH/AL(8位)
新增8个寄存器: r8-r15

x64参数传递

x86: 参数通过栈传递
x64: 前四个参数通过寄存器传递(rdi, rsi, rdx, rcx)
超过四个参数时，额外参数仍通过栈传递

x64新指令
LEAVE指令:

函数尾声的简写
内部等价于: mov + pop指令组合

类型转换指令:
assemblyMOVSX   ; 符号扩展(用符号位填充高位)
MOVSXD  ; 32位到64位的符号扩展
MOVZX   ; 零扩展(用0填充高位)

MOVSX和MOVZX可能表示类型转换操作


可能考题及答案
选择题 (MCQs)
Q1: 在x86架构中，栈的增长方向是？
A) 从低地址到高地址
B) 从高地址到低地址
C) 双向增长
D) 随机方向
答案: B - 栈从高地址向低地址增长
Q2: 函数序言(prologue)的标准指令序列是？
A) push ebp; mov esp, ebp; sub esp, X
B) push ebp; mov ebp, esp; sub esp, X
C) mov ebp, esp; push ebp; sub esp, X
D) sub esp, X; push ebp; mov ebp, esp
答案: B - 标准序列是保存旧EBP，设置新EBP，分配局部变量空间
Q3: rep movsb指令等价于C语言中的哪个函数？
A) strcpy()
B) memcpy()
C) strlen()
D) strcmp()
答案: B - rep movsb用于内存块复制，等价于memcpy()
Q4: 在x64架构中，函数的前四个参数通过哪些寄存器传递？
A) eax, ebx, ecx, edx
B) rax, rbx, rcx, rdx
C) rdi, rsi, rdx, rcx
D) r8, r9, r10, r11
答案: C - x64使用rdi, rsi, rdx, rcx传递前四个参数
简答题 (Short Questions)
Q1: 解释ESP和EBP寄存器在函数调用中的作用。(5分)
答案:

ESP (Stack Pointer): 始终指向栈顶，跟踪当前栈的位置
EBP (Base Pointer): 用作函数的基址指针，指示函数栈帧的起始位置
函数调用时，旧的EBP被保存，ESP的值成为新的EBP
通过EBP的偏移可以访问函数参数(正偏移)和局部变量(负偏移)

Q2: 如何在汇编代码中识别循环结构？(5分)
答案:
循环结构的特征包括：

前向跳转指令(条件跳转，如jge, jz等)
无条件后向跳转指令(jmp)
比较指令(cmp)
循环变量的递增/递减操作
典型模式：初始化 → 比较 → 条件跳出 → 循环体 → 更新变量 → 无条件跳回

Q3: 数组和结构体在内存访问上有什么区别？(5分)
答案:

数组:

相同数据类型的元素
通过[base + index × size]公式访问
元素大小固定且相同


结构体:

不同数据类型的成员
通过固定偏移量访问成员
成员大小可能不同
访问模式：[base + fixed_offset]



长题 (Long Questions)
Q1: 分析以下汇编代码，说明其对应的高级语言结构，并解释每条指令的作用。(15分)
assemblypush ebp
mov ebp, esp
sub esp, 8
mov dword ptr [ebp-8], 1
mov dword ptr [ebp-4], 0
label1:
cmp dword ptr [ebp-4], 5
jge short label2
mov eax, [ebp-8]
add eax, [ebp-4]
mov [ebp-8], eax
mov ecx, [ebp-4]
add ecx, 1
mov [ebp-4], ecx
jmp short label1
label2:
mov esp, ebp
pop ebp
ret
答案:
这是一个包含循环的函数，对应的C代码类似：
cint function() {
    int sum = 1;     // [ebp-8]
    int i = 0;       // [ebp-4]
    
    while(i < 5) {
        sum = sum + i;
        i = i + 1;
    }
    return sum;
}
指令解释:

push ebp; mov ebp, esp; sub esp, 8: 函数序言，建立栈帧，分配8字节局部变量空间
mov dword ptr [ebp-8], 1: 初始化sum = 1
mov dword ptr [ebp-4], 0: 初始化i = 0
label1: 循环开始标签
cmp dword ptr [ebp-4], 5; jge short label2: 比较i和5，如果i≥5则跳出循环
mov eax, [ebp-8]; add eax, [ebp-4]; mov [ebp-8], eax: sum = sum + i
mov ecx, [ebp-4]; add ecx, 1; mov [ebp-4], ecx: i = i + 1
jmp short label1: 无条件跳回循环开始
label2: 循环结束标签
mov esp, ebp; pop ebp; ret: 函数尾声，恢复栈帧并返回

Q2: 解释x86和x64架构在函数调用约定上的主要区别，并说明这些区别对恶意软件分析的影响。(20分)
答案:
主要区别:

参数传递方式:

x86: 所有参数通过栈传递，从右到左压栈
x64: 前四个参数通过寄存器(rdi, rsi, rdx, rcx)传递，剩余参数通过栈传递


寄存器大小:

x86: 32位寄存器(eax, ebx等)
x64: 64位寄存器(rax, rbx等)，向下兼容32位


地址空间:

x86: 32位地址空间(4GB)
x64: 64位地址空间，实际使用48位


新增寄存器:

x64新增r8-r15寄存器



对恶意软件分析的影响:

参数识别更困难: x64中需要同时关注寄存器和栈来确定函数参数
代码体积: x64代码可能更紧凑(寄存器传参减少栈操作)
混淆技术: 攻击者可能利用架构差异进行反分析
工具兼容性: 需要支持两种架构的分析工具
内存布局: 64位环境下ASLR更有效，增加分析难度
API调用分析: 需要理解不同架构下的调用约定来正确识别API调用
