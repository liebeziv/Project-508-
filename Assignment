Part1 答案
1. 这是可执行文件还是 DLL？
分析: 在 File Header 的 Characteristics 字段中，弹出的提示显示 "File is executable"。
答案: 这是一个可执行文件（.exe）。

2. NT Header/PE Header 从哪个地址开始？
分析: 在 DOS Header 部分，e_lfanew 字段（或称 File address of new exe header）的值指向了 PE Header 的起始地址。
答案: PE Header 的起始地址是 80（十六进制）。

3. 该 PE 文件包含多少个节以及它们是什么？
分析: 在 Section Headers 部分，可以清楚地看到一个包含所有节的列表。
答案: 该文件包含 3 个节，它们分别是 .text、.rsrc 和 .reloc。

4. 入口点地址是什么？
分析: 在 Optional Header 部分，AddressOfEntryPoint 字段的值就是入口点地址。在 PE-Bear 中，该字段显示为 Entry Point。
答案: 入口点地址是 6B4E。

5. 该二进制文件导入和导出了哪些函数？
分析:
在 Imports 部分，该文件从 mscoree.dll 导入了一个名为 _CorExeMain 的函数。
在 Exports 部分，该列表为空。
答案: 该文件从 mscoree.dll 导入了 _CorExeMain 函数，但没有导出任何函数。

6. 该文件能否处理大型地址集？
分析: 有多处证据可以证明：
File Header 的 Characteristics 字段提示 "App can handle >2gb addresses"。
Optional Header 的 Dll Characteristics 字段提示 "Image can handle a high entropy 64-bit virtual address"。
Optional Header 的 Magic 字段值为 10B，表示这是一个 32 位可执行文件，能够处理大于 2GB 的地址空间。
答案: 该文件能够处理大型地址集。

Part2 答案
rule ransomware1_rule
{
  meta:
      author = "Zhengrong Chen"
      description= "依照字符串和文件的属性检测可执行文件ransomware1.exe."
      date = "2025-08-25"
      version = "1.0"

  strings:
      $s1 = "mscoree.dll" wide ascii
      $s2 = "_CoreExeMain" wide ascii

  condition:
      ($s1 and $ s2) and
      pe.entry_point == 0x6B4E and
      pe.number_of_ssections == 3  and
      sha256(0) == "a872d7b04d9d3e9ace68ea1524d278bf35a24a4a1f9ec9f067cdfaf34a88c8a4"

}

Part3答案
1.XZ Utils后门是一种复杂的供应链攻击，其核心思想是将恶意代码秘密地植入一个广泛使用的开源库中，从而使攻击者能够获得大量系统的远程控制。
Exploitation：攻击者通过在版本5.6.0和5.6.1的XZ Utils库中植入恶意代码来利用这一漏洞。这个代码被巧妙地隐藏在压缩的测试文件内，只有在特定的编译环境下才会被激活。当被攻击的Linux系统启动时，sshd(OpenSSH server daemon）会加载被篡改的liblzma库。恶意代码通过利用glibc IFUNC机制，劫持了OpenSSH的一个函数（RSA_public_decrrypt)，使其能够执行攻击者的代码。
Impact：该后门程序可以让攻击者在拥有特定私钥的情况下，绕过SSH认证，并在受影响的系统上远程执行任意代码，并且获得root权限。这意味着攻击者可以完全控制受感染的机器，包括窃取数据，安装其他恶意软件，或发起进一步攻击，对全球无数服务器构成严重威胁。

2.这个漏洞是由微软的工程师和PostgreSQL开发者Andres Freund在一次例行调查中偶然发现的。
例行调查：Freund在调查Debian Sid系统上的性能问题时，注意到sshd进程的CPU使用率异常高，且Valgrind报告了奇怪的错误。
深入调查：这引起了Freund的警觉。他进一步深入调查，最终追踪到了libsystem库，并发现了代码被篡改，进而发现了隐藏在xz库中的恶意后门。
及时公布：Freund在2024年3月29日将他的发现公开在Openwall邮件列表上，该行为引起了全球范围内使用者的警觉和响应，有效阻止了该后门在其他系统上的部署和利用。

Part4答案：
搜索结果来源于VirusTotal
Hash1: 054314733888215dd469adcbdee14d46
威胁类别：Trojan和ransomware。是encoder属于lockbit家族。
行为解释：
  文件行为：作为勒索软件，最主要的文件系统行为是加密。这类恶意软件会遍历受害者计算机上的文件和目录，对重要文件进行加密。
  注册表：勒索软件通常会修改注册表实现持久化，并在系统中写入对应的赎金路径，指引受害者如何支付赎金。

Hash2: d3adaf9006e37df3eed462ec9dee7eef30ac36e9
威胁类别：Click-fraud，以及无文件恶意软件。属于Kovter恶意软件家族
行为解释：
  文件行为：Kovter的特点是无文件。意味着在多数情况下，不依赖于系统上的可执行文件作为其主要恶意载荷。
  注册表：该恶意软件利用了注册表作为其主要储存和执行机制。它会修改注册表键，并且将恶意代码注入其中，从而实现持久化的存在。主要功能是通过
  这些注册表在后台执行点击欺诈活动。

Part5答案：
1.代码1：加密和数据持久化
该代码实现了两种核心功能：数据加密和密钥持久化
加密：代码使用了RijndaeManaged类来生成密钥（Rij.GenerateKey())以及初始化向量(Rij.GenerateIV())。使用一个名为encryptAES的函数对
输入数据bhytes进行加密。这是一种对称加密算法，常用于勒索软件加密文件。
持久化：代码通过Registry.CurrentUsser.OpenSubKey("Software\Microsoft", true);打开Windows注册表键。然后，它将生成的加密密钥和IV值
分别以“KeyValue”和“IVvalue”的形式写入这个新创建的注册表键中。这种行为旨在保存加密所需的关键信息，以便恶意软件在后续运用时的使用。

2.代码2：反虚拟机检测
该代码实现了反虚拟机（Anti-VM）功能
代码通过调用CreateToolhelp32Snapshot和Process32First/Process32Next函数来遍历所有正在运行中的进程。
在if语句中，它检查每个进程中的可执行文件名(pe32.szExeFile)是否包含"VMware"或是“Vbox"。常见的虚拟机都会包含这类名称。
如果检测到对应的字符串，代码将会打印"FINISH PROCESSING..."和"GOODBYE：）"的信息，并立刻退出程序。躲避在虚拟机中进行的恶意软件分析。

3.代码3：持久化
该代码实现了持久化功能，确保恶意软件可以在系统启动时自动运行
代码使用“Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true)” 打开了Windows注册表中
的Run键。
使用regk.SetValue("backup", Application.ExecutablePath)将名为“backup”的新注册表键写入该键。
Application.ExecutablePath代表当前恶意可执行文件的完整路径。通过将此路径写入Run键，Windows将在每次用户登录时自动执行该程序。

4.代码4：权限提升或持久化
该Powershell脚本旨在利用不安全的系统配置来实现权限提升
代码获取“%PATH”环境变量中列出的所有目录。
使用“Get-Acl”cmdlet检查每个目录的访问控制列表，以确定当前用户是（$curruser）是否具有"Write"或"FullControl"的权限。
如果用户对某个目录有写入权限，脚本会开始执行Copy-Item命令，将一个名为"cmd.exe"的文件从用户的桌面“C:\Users\User\Desktop\cmd.exe”复制
到该可写入的目录中。这种行为可以用于劫持合法命令或将恶意文件放置在系统路径中，从而在用户或系统执行常规命令时运行恶意外码。

Part6答案：
Task1：
程序实现了一个基本的凯撒密码系统，采用菜单驱动界面。包含了四个函数：Main，FUN01-菜单控制，FUN02-加密，FUN03-解密。
Main函数分析：

第004012b3行：CALL FUN01 - 调用主菜单函数
第004012b8行：XOR EAX,EAX - 将返回值设为0
标准的函数序言和结尾（PUSH EBP, MOV EBP,ESP, POP EBP, RET）

FUN01函数详细分析：
函数序言（004011c0-004011c3）：标准的栈帧建立，分配8字节局部变量空间
第一个printf调用（004011d0-004011da）：
第004011d0行：PUSH .data - 推送菜单字符串地址到栈
第004011d5行：CALL printf - 显示菜单选项
第004011da行：ADD ESP,0x4 - 清理栈（移除参数）


scanf_s调用（004011dd-004011eb）：
第004011dd行：LEA EAX=>local_c,[EBP + -0x8] - 获取局部变量地址
第004011e0-004011e1行：推送参数（变量地址和格式字符串）
第004011e6行：CALL scanf_s - 读取用户输入
第004011eb行：ADD ESP,0x8 - 清理栈（移除两个参数）


条件分支逻辑：
第一个条件检查（004011ee-004011f2）：
CMP dword ptr [EBP + local_c],0x1 - 比较用户输入与1
JNZ LAB_004011fc - 如果不等于1，跳转到下一个检查
如果等于1：调用FUN02（加密函数）

第二个条件检查（004011fc-00401200）：
CMP dword ptr [EBP + local_c],0x2 - 比较用户输入与2
JNZ LAB_0040120a - 如果不等于2，跳转到错误处理
如果等于2：调用FUN03（解密函数）

错误处理（0040120a-00401214）：
第0040120a行：PUSH s_Invlalid_option._00404038 - 推送"无效选项"字符串
第0040120f行：CALL printf - 显示错误消息


FUN02和FUN03函数分析：
文件操作：
两个函数都执行相似的文件打开操作
FUN02：打开"File.txt"（读取）和"File1.txt"（写入）
FUN03：打开"File1.txt"（读取）和"File2.txt"（写入）

主处理循环：
循环入口：LAB_00401112（FUN02）和LAB_00401032（FUN03）
文件读取：从输入文件读取一个字符
EOF检查：第00401126和00401046行 - CMP ECX,-0x1 检查是否到达文件末尾
字符处理逻辑：
检查字符是否为字母
根据大小写设置基准值（'A'=0x41 或 'a'=0x61）
加密算法（FUN02）：(字符 - 基准 + 3) % 26 + 基准
解密算法（FUN03）：(字符 - 基准 + 23) % 26 + 基准

模运算实现：
第00401172-00401178行：使用IDIV指令实现除以26的模运算
EDX寄存器保存余数结果

循环控制：
第00401195行（FUN02）和004010b5行（FUN03）：JMP 回到循环开始
循环直到遇到EOF字符(-1)为止

函数结束：
两个函数都以文件关闭操作结束
标准的函数结尾序列（恢复栈指针和基指针）

关键特征：
程序使用Caesar密码算法，移位量为3
保持字母的大小写特性
非字母字符不进行转换
使用模26运算确保字母在正确范围内循环

