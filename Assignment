Part1 答案
1. 这是可执行文件还是 DLL？
分析: 在 File Header 的 Characteristics 字段中，弹出的提示显示 "File is executable"。
答案: 这是一个可执行文件（.exe）。

2. NT Header/PE Header 从哪个地址开始？
分析: 在 DOS Header 部分，e_lfanew 字段的值指向了 PE Header 的起始地址。
答案: PE Header 的起始地址是 80（十六进制）。

3. 该 PE 文件包含多少个节以及它们是什么？
分析: 在 Section Headers 部分，一个包含所有节的列表。
答案: 该文件包含 3 个节，它们分别是 .text、.rsrc 和 .reloc。

4. 入口点地址是什么？
分析: 在 Optional Header 部分，AddressOfEntryPoint 字段的值就是入口点地址。在 PE-Bear 中，该字段显示为 Entry Point。
答案: 入口点地址是 6B4E。

5. 该二进制文件导入和导出了哪些函数？
分析:
在 Imports 部分，该文件从 mscoree.dll 导入了一个名为 _CorExeMain 的函数。
在 Exports 部分，该列表为空。
答案: 该文件从 mscoree.dll 导入了 _CorExeMain 函数，但没有导出任何函数。

6. 该文件能否处理大型地址集？
分析: 有多处证据可以证明：
File Header 的 Characteristics 字段提示 "App can handle >2gb addresses"。
Optional Header 的 Dll Characteristics 字段提示 "Image can handle a high entropy 64-bit virtual address"。
Optional Header 的 Magic 字段值为 10B，表示这是一个 32 位可执行文件，能够处理大于 2GB 的地址空间。
答案: 该文件能够处理大型地址集。

Part2 答案
rule ransomware1_rule
{
  meta:
      author = "Zhengrong Chen"
      description= "依照字符串和文件的属性检测可执行文件ransomware1.exe."
      date = "2025-08-25"
      version = "1.0"

  strings:
      $s1 = "mscoree.dll" wide ascii
      $s2 = "_CoreExeMain" wide ascii

  condition:
      ($s1 and $ s2) and
      pe.entry_point == 0x6B4E and
      pe.number_of_ssections == 3  and
      sha256(0) == "a872d7b04d9d3e9ace68ea1524d278bf35a24a4a1f9ec9f067cdfaf34a88c8a4"

}

Part3答案
1.XZ Utils后门是一种复杂的供应链攻击，其核心思想是将恶意代码秘密地植入一个广泛使用的开源库中，从而使攻击者能够获得大量系统的远程控制。
Exploitation：攻击者通过在版本5.6.0和5.6.1的XZ Utils库中植入恶意代码来利用这一漏洞。这个代码被巧妙地隐藏在压缩的测试文件内，只有在特定的编译环境下才会被激活。当被攻击的Linux系统启动时，sshd(OpenSSH server daemon）会加载被篡改的liblzma库。恶意代码通过利用glibc IFUNC机制，劫持了OpenSSH的一个函数（RSA_public_decrrypt)，使其能够执行攻击者的代码。
Impact：该后门程序可以让攻击者在拥有特定私钥的情况下，绕过SSH认证，并在受影响的系统上远程执行任意代码，并且获得root权限。这意味着攻击者可以完全控制受感染的机器，包括窃取数据，安装其他恶意软件，或发起进一步攻击，对全球无数服务器构成严重威胁。

2.这个漏洞是由微软的工程师和PostgreSQL开发者Andres Freund在一次例行调查中偶然发现的。
例行调查：Freund在调查Debian Sid系统上的性能问题时，注意到sshd进程的CPU使用率异常高，且Valgrind报告了奇怪的错误。
深入调查：这引起了Freund的警觉。他进一步深入调查，最终追踪到了libsystem库，并发现了代码被篡改，进而发现了隐藏在xz库中的恶意后门。
及时公布：Freund在2024年3月29日将他的发现公开在Openwall邮件列表上，该行为引起了全球范围内使用者的警觉和响应，有效阻止了该后门在其他系统上的部署和利用。

Part4答案：
搜索结果来源于VirusTotal
Hash1: 054314733888215dd469adcbdee14d46
威胁类别：Trojan和ransomware。是encoder属于lockbit家族。
行为解释：
  文件行为：作为勒索软件，最主要的文件系统行为是加密。这类恶意软件会遍历受害者计算机上的文件和目录，对重要文件进行加密。
  注册表：勒索软件通常会修改注册表实现持久化，并在系统中写入对应的赎金路径，指引受害者如何支付赎金。

Hash2: d3adaf9006e37df3eed462ec9dee7eef30ac36e9
威胁类别：Click-fraud，以及无文件恶意软件。属于Kovter恶意软件家族
行为解释：
  文件行为：Kovter的特点是无文件。意味着在多数情况下，不依赖于系统上的可执行文件作为其主要恶意载荷。
  注册表：该恶意软件利用了注册表作为其主要储存和执行机制。它会修改注册表键，并且将恶意代码注入其中，从而实现持久化的存在。主要功能是通过
  这些注册表在后台执行点击欺诈活动。

Part5答案：
1.代码1：加密和数据持久化
该代码实现了两种核心功能：数据加密和密钥持久化
加密：代码使用了RijndaeManaged类来生成密钥（Rij.GenerateKey())以及初始化向量(Rij.GenerateIV())。使用一个名为encryptAES的函数对
输入数据bhytes进行加密。这是一种对称加密算法，常用于勒索软件加密文件。
持久化：代码通过Registry.CurrentUsser.OpenSubKey("Software\Microsoft", true);打开Windows注册表键。然后，它将生成的加密密钥和IV值
分别以“KeyValue”和“IVvalue”的形式写入这个新创建的注册表键中。这种行为旨在保存加密所需的关键信息，以便恶意软件在后续运用时的使用。

2.代码2：反虚拟机检测
该代码实现了反虚拟机（Anti-VM）功能
代码通过调用CreateToolhelp32Snapshot和Process32First/Process32Next函数来遍历所有正在运行中的进程。
在if语句中，它检查每个进程中的可执行文件名(pe32.szExeFile)是否包含"VMware"或是“Vbox"。常见的虚拟机都会包含这类名称。
如果检测到对应的字符串，代码将会打印"FINISH PROCESSING..."和"GOODBYE：）"的信息，并立刻退出程序。躲避在虚拟机中进行的恶意软件分析。

3.代码3：持久化
该代码实现了持久化功能，确保恶意软件可以在系统启动时自动运行
代码使用“Registry.LocalMachine.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true)” 打开了Windows注册表中
的Run键。
使用regk.SetValue("backup", Application.ExecutablePath)将名为“backup”的新注册表键写入该键。
Application.ExecutablePath代表当前恶意可执行文件的完整路径。通过将此路径写入Run键，Windows将在每次用户登录时自动执行该程序。

4.代码4：权限提升或持久化
该Powershell脚本旨在利用不安全的系统配置来实现权限提升
代码获取“%PATH”环境变量中列出的所有目录。
使用“Get-Acl”cmdlet检查每个目录的访问控制列表，以确定当前用户是（$curruser）是否具有"Write"或"FullControl"的权限。
如果用户对某个目录有写入权限，脚本会开始执行Copy-Item命令，将一个名为"cmd.exe"的文件从用户的桌面“C:\Users\User\Desktop\cmd.exe”复制
到该可写入的目录中。这种行为可以用于劫持合法命令或将恶意文件放置在系统路径中，从而在用户或系统执行常规命令时运行恶意外码。

Part6答案：
Task1：
程序实现了一个基本的凯撒密码系统，采用菜单驱动界面。包含了四个函数：Main，FUN01-菜单控制，FUN02-加密，FUN03-解密。
Main函数分析：

函数调用：

第004012b3行：CALL FUN01 - main函数调用菜单函数
第004011d5行：CALL printf - FUN01中显示菜单选项
第004011e6行：CALL scanf_s - FUN01中读取用户选择
第004011f4行：CALL FUN02 - 当选择选项1时调用加密函数
第00401202行：CALL FUN03 - 当选择选项2时调用解密函数
第0040120f行：CALL printf - 显示"无效选项"消息
FUN02和FUN03中的文件I/O函数调用（文件打开、读取、写入、关闭操作）

条件语句：

第004011ee-004011f2行：CMP dword ptr [EBP + local_c],0x1 和 JNZ LAB_004011fc - 检查用户输入是否等于1
第004011fc-00401200行：CMP dword ptr [EBP + local_c],0x2 和 JNZ LAB_0040120a - 检查用户输入是否等于2
第00401126行（FUN02）和第00401046行（FUN03）：CMP ECX,-0x1 和 JZ - 检查文件结束条件
第0040114b行（FUN02）和第0040106b行（FUN03）：字符大小写检测的条件判断

循环：

FUN02中的循环：从LAB_00401112开始的主处理循环，通过第00401195行的JMP LAB_00401112实现循环，处理输入文件中的每个字符直到EOF
FUN03中的循环：从LAB_00401032开始的主处理循环，通过第004010b5行的JMP LAB_00401032实现循环，处理输入文件中的每个字符直到EOF

Task2：

主函数

函数 main():
    调用 FUN01()
    返回 0


菜单函数 FUN01

函数 FUN01():
    打印菜单选项
    读取用户选择到本地变量
    
    如果 用户选择 == 1 那么
        调用 FUN02()
    否则如果 用户选择 == 2 那么
        调用 FUN03()
    否则
        打印 "无效选项"
    结束如果
    返回


加密函数 FUN02

函数 FUN02():
    打开文件 "File.txt" 用于读取 -> 存储到变量
    打开文件 "File1.txt" 用于写入 -> 存储到变量
    
    循环:
        从输入文件读取一个字符
        
        如果 字符值 == -1 (EOF) 那么
            跳出循环
        结束如果
        
        如果 字符是字母 那么
            如果 字符是大写字母 那么
                基准值 = 65 (ASCII 'A')
            否则
                基准值 = 97 (ASCII 'a')
            结束如果
            
            计算: (字符 - 基准值 + 3) 除以 26 取余数
            新字符 = 余数 + 基准值
            字符 = 新字符
        结束如果
        
        将字符写入输出文件
    结束循环
    
    关闭输入文件
    关闭输出文件
    返回


解密函数 FUN03

函数 FUN03():
    打开文件 "File1.txt" 用于读取 -> 存储到变量
    打开文件 "File2.txt" 用于写入 -> 存储到变量
    
    循环:
        从输入文件读取一个字符
        
        如果 字符值 == -1 (EOF) 那么
            跳出循环
        结束如果
        
        如果 字符是字母 那么
            如果 字符是大写字母 那么
                基准值 = 65 (ASCII 'A')
            否则
                基准值 = 97 (ASCII 'a')
            结束如果
            
            计算: (字符 - 基准值 + 23) 除以 26 取余数
            新字符 = 余数 + 基准值
            字符 = 新字符
        结束如果
        
        将字符写入输出文件
    结束循环
    
    关闭输入文件
    关闭输出文件
    返回

Task3：

  
